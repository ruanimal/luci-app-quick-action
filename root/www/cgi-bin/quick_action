#!/bin/sh

# CGI script for Quick Action HTTP API with token authentication
# Supports token via URL parameter (?token=xxx) or Header (X-Quick-Action-Token)

. /lib/functions.sh
. /usr/share/libubox/jshn.sh

# Content-Type header
echo "Content-Type: application/json"
echo ""

# Get token from URL parameter or Authorization header
get_token() {
	local token=""

	# Try URL parameter first
	if [ -n "$QUERY_STRING" ]; then
		token=$(echo "$QUERY_STRING" | sed -n 's/.*token=\([^&]*\).*/\1/p')
	fi

	# Try Authorization header (Bearer token) if not found in URL
	if [ -z "$token" ] && [ -n "$HTTP_AUTHORIZATION" ]; then
		# Extract token from "Bearer <token>" format
		token=$(echo "$HTTP_AUTHORIZATION" | sed -n 's/^Bearer //p')
	fi

	echo "$token"
}

# Rate limiting - max 10 failed attempts per IP in 5 minutes
RATE_LIMIT_FILE="/tmp/quick_action_rate_limit"
RATE_LIMIT_MAX_SIZE=10240  # 10KB max file size

check_rate_limit() {
	local client_ip="${REMOTE_ADDR:-unknown}"
	local now=$(date +%s)
	local window=300  # 5 minutes
	local max_attempts=10
	local cutoff=$((now - window))

	# Check file size and clean if too large or has old entries
	if [ -f "$RATE_LIMIT_FILE" ]; then
		local file_size=$(stat -c%s "$RATE_LIMIT_FILE" 2>/dev/null || echo 0)

		# If file too large, truncate it
		if [ "$file_size" -gt "$RATE_LIMIT_MAX_SIZE" ]; then
			# Keep only recent entries (last 100 lines within window)
			tail -100 "$RATE_LIMIT_FILE" 2>/dev/null | \
				awk -F: -v cutoff="$cutoff" '$3 > cutoff' > "${RATE_LIMIT_FILE}.tmp" 2>/dev/null
			mv "${RATE_LIMIT_FILE}.tmp" "$RATE_LIMIT_FILE" 2>/dev/null
		fi
	fi

	# Count recent failures for this IP
	local count=0
	if [ -f "$RATE_LIMIT_FILE" ]; then
		count=$(awk -F: -v ip="$client_ip" -v cutoff="$cutoff" \
			'$1 == ip && $3 > cutoff {c++} END {print c+0}' "$RATE_LIMIT_FILE" 2>/dev/null)
	fi

	[ "$count" -lt "$max_attempts" ]
}

record_failed_attempt() {
	local client_ip="${REMOTE_ADDR:-unknown}"
	local now=$(date +%s)
	echo "${client_ip}:failed:${now}" >> "$RATE_LIMIT_FILE" 2>/dev/null
}

# Validate token
validate_token() {
	local check_token="$1"
	local valid=0

	# Rate limit check FIRST - block before any processing
	if ! check_rate_limit; then
		return 1
	fi

	# Empty token - fail without recording (no attempt made)
	if [ -z "$check_token" ]; then
		return 1
	fi

	# Token too short - record as failed attempt
	if [ ${#check_token} -lt 8 ]; then
		record_failed_attempt
		return 1
	fi

	config_load quick_action

	check_token_valid() {
		local section="$1"
		local token enabled expires

		config_get token "$section" token
		config_get enabled "$section" enabled "1"
		config_get expires "$section" expires "0"

		if [ "$token" = "$check_token" ] && [ "$enabled" = "1" ]; then
			# Check expiration (0 = never expires)
			if [ "$expires" = "0" ] || [ "$expires" -gt "$(date +%s)" ]; then
				valid=1
			fi
		fi
	}

	config_foreach check_token_valid token

	# Record failed attempt if token invalid
	if [ "$valid" != "1" ]; then
		record_failed_attempt
	fi

	[ "$valid" = "1" ]
}

# Get parameter from query string
get_param() {
	local param_name="$1"
	echo "$QUERY_STRING" | sed -n "s/.*${param_name}=\([^&]*\).*/\1/p" | sed 's/+/ /g' | sed 's/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf "%b"
}

# List all commands
list_commands() {
	json_init
	json_add_boolean "success" 1
	json_add_array "commands"

	config_load quick_action

	list_command() {
		local section="$1"
		local name description type enabled

		config_get name "$section" name
		config_get description "$section" description
		config_get type "$section" type "shell"
		config_get enabled "$section" enabled "1"

		if [ -n "$name" ]; then
			json_add_object ""
			json_add_string "id" "$section"
			json_add_string "name" "$name"
			json_add_string "description" "$description"
			json_add_string "type" "$type"
			json_add_boolean "enabled" "$enabled"
			json_close_object
		fi
	}

	config_foreach list_command command

	json_close_array
	json_dump
}

# Find command section by name
find_command_by_name() {
	local search_name="$1"
	local found_section=""

	find_section() {
		local section="$1"
		local name
		config_get name "$section" name

		if [ "$name" = "$search_name" ]; then
			found_section="$section"
		fi
	}

	config_foreach find_section command
	echo "$found_section"
}

# Run a command by name
run_command() {
	local cmd_name="$1"

	config_load quick_action

	# 通过 name 查找命令的 section ID
	local cmd_id
	cmd_id=$(find_command_by_name "$cmd_name")

	if [ -z "$cmd_id" ]; then
		json_init
		json_add_boolean "success" 0
		json_add_string "error" "Command not found: $cmd_name"
		json_dump
		return 1
	fi

	local name type exec ubus_object ubus_method ubus_params enabled
	config_get name "$cmd_id" name
	config_get type "$cmd_id" type "shell"
	config_get exec "$cmd_id" exec
	config_get ubus_object "$cmd_id" ubus_object
	config_get ubus_method "$cmd_id" ubus_method
	config_get ubus_params "$cmd_id" ubus_params
	config_get enabled "$cmd_id" enabled "1"

	if [ "$enabled" != "1" ]; then
		json_init
		json_add_boolean "success" 0
		json_add_string "error" "Command is disabled"
		json_dump
		return 1
	fi

	# Execute the command based on type
	local output ret

	if [ "$type" = "ubus" ]; then
		# Execute ubus call
		if [ -z "$ubus_object" ] || [ -z "$ubus_method" ]; then
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "ubus_object and ubus_method are required for ubus type"
			json_dump
			return 1
		fi

		if [ -n "$ubus_params" ]; then
			output=$(ubus call "$ubus_object" "$ubus_method" "$ubus_params" 2>&1)
		else
			output=$(ubus call "$ubus_object" "$ubus_method" 2>&1)
		fi
		ret=$?
	else
		# Execute shell command
		output=$(eval "$exec" 2>&1)
		ret=$?
	fi

	json_init
	if [ $ret -eq 0 ]; then
		json_add_boolean "success" 1
		json_add_string "message" "Command executed successfully"
		json_add_string "output" "$output"
	else
		json_add_boolean "success" 0
		json_add_string "error" "Command execution failed"
		json_add_string "output" "$output"
		json_add_int "exit_code" "$ret"
	fi
	json_dump
}

# Error response
error_response() {
	local message="$1"
	json_init
	json_add_boolean "success" 0
	json_add_string "error" "$message"
	json_dump
}

# Main logic
main() {
	# Get and validate token
	local token
	token=$(get_token)

	if ! validate_token "$token"; then
		error_response "Invalid or missing token"
		exit 0
	fi

	# Get action parameter
	local action
	action=$(get_param "action")

	case "$action" in
		list)
			list_commands
			;;
		run)
			local cmd
			cmd=$(get_param "cmd")
			if [ -z "$cmd" ]; then
				error_response "Missing 'cmd' parameter"
			else
				run_command "$cmd"
			fi
			;;
		*)
			error_response "Invalid action. Use 'list' or 'run'"
			;;
	esac
}

main
